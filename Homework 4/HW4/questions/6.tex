\subsection*{الف}
در مدل
\lr{FIFO}
قدیمی ترین صفحه را در مموری که ابتدا وارد شده بود را جایگزین می‌کند. در واقع همانند صف می‌ماند که صفحات جدید به انتها اضافه شده و صفحات قبلی از صف خارج می‌شوند. برای ترتیب در‌خواست‌های داده شده با استفاده از این روش خواهیم داشت:
\begin{align*}
1.\,\, &Start: [] \\
2.\,\, &Request\, 1: [1] \\
3.\,\, &Request\, 3: [1, 3] \\
4.\,\, &Request\, 5: [1, 3, 5] \\
5.\,\, &Request\, 7: [1, 3, 5, 7] \\
6.\,\, &Request\, 8: [3, 5, 7, 8] \\
7.\,\, &Request\, 1: [5, 7, 8, 1] \\
8.\,\, &Request\, 4: [7, 8, 1, 4] \\
9.\,\, &Request\, 4: [7, 8, 1, 4] \,\, No Page Fault \\
10.\,\, &Request\, 3: [8, 1, 4, 3] \\
11.\,\, &Request\, 2: [1, 4, 3, 2] \\
12.\,\, &Request\, 4: [1, 4, 3, 2] \,\, No Page Fault \\
13.\,\, &Request\, 5: [4, 3, 2, 5] \\
14.\,\, &Request\, 1: [3, 2, 5, 1] \\
15.\,\, &Request\, 7: [2, 5, 1, 7] \\
16.\,\, &Request\, 1: [2, 5, 1, 7] \,\, No Page Fault \\
\end{align*}

\subsection*{ب}
الگوریتم \lr{LRU} با شانس دوم یک نوع از الگوریتم کمتر استفاده شده یا همان \lr{LRU} هست که بعضی ویژگی‌های روش \lr{FIFO} را هم شامل می‌شود. تو این الگوریتم، هر صفحه‌ای که تو حافظه هست یه بیت مرجع داشته، که اولش به صورت پیش‌فرض روی 0 تنظیم شده. وقتی به یه صفحه دسترسی پیدا می‌شه، بیت مرجعش به 1 تغییر می‌کنه. حالا، وقتی بخوایم یه صفحه رو با یه صفحه دیگه جایگزین کنیم، این الگوریتم صفحه‌ها رو به ترتیب \lr{FIFO} (اولین صفحه‌ای که وارد شده، اولین صفحه‌ای که خارج می‌شه) بررسی می‌کنه و دنبال یه صفحه با بیت مرجع 0 می‌گردد.

اگه به صفحه‌ای با بیت مرجع 1 برخورد کرد، اون بیت رو دوباره به 0 تغییر می‌دهد و به اون صفحه یه «شانس دوم» می‌ده، یعنی اونو می‌بره انتهای صف و جستجو رو ادامه می‌ده. این فرایند ادامه پیدا می‌کنه تا زمانی که به یه صفحه با بیت مرجع 0 برسه و اونو جایگزین کنه.

نکته مهم اینه که بیت‌های مرجع هر بار که به صفحه‌ای دسترسی پیدا می‌شه، چه در مواقع برخورد (\lr{hits}) و چه در مواقع عدم برخورد (\lr{misses})، به‌روزرسانی می‌شن. اگه یه صفحه چندین بار قبل از اینکه برای جایگزینی در نظر گرفته بشه، دسترسی پیدا کنه، بیت مرجعش همچنان روی 1 باقی می‌مونه و این باعث می‌شه شانس بیشتری داشته باشه که تو حافظه بماند.

به این ترتیب برای درخواست‌های داده شده خواهیم داشت:
\begin{align*}
1.\,\,  &Start: [] \\
2.\,\,  &Request\, 1: [1] \\
3.\,\,  &Request\, 3: [1, 3] \\
4.\,\,  &Request\, 5: [1, 3, 5] \\
5.\,\,  &Request\, 7: [1, 3, 5, 7] \\
6.\,\,  &Request\, 8: [3, 5, 7, 8] \\
7.\,\,  &Request\, 1: [5, 7, 8, 1] \\
8.\,\,  &Request\, 4: [7, 8, 1, 4] \\
9.\,\,  &Request\, 4: [7, 8, 1, 4] \,\, No Page Fault \\
10.\,\, &Request\, 3: [8, 1, 4, 3] \\
11.\,\, &Request\, 2: [1, 4, 3, 2] \\
12.\,\, &Request\, 4: [1, 4, 3, 2] \,\, No Page Fault \\
13.\,\, &Request\, 5: [4, 3, 2, 5] \\
14.\,\, &Request\, 1: [3, 2, 5, 1] \\
15.\,\, &Request\, 7: [2, 5, 1, 7] \\
16.\,\, &Request\, 1: [2, 5, 1, 7] \,\, No Page Fault
\end{align*}

\subsection*{ج}
الگوریتم \lr{LFU} یا کمترین استفاده شده، یک روش مدیریت حافظه است که به صفحاتی که کمتر استفاده شده‌اند اولویت می‌دهد. هر صفحه یک شمارنده دارد که نشون می‌دهد چند بار بهش دسترسی پیدا شده است. وقتی نیاز به جایگزین کردن یک صفحه باشد، صفحه‌ای که کمترین تعداد دسترسی رو داشته انتخاب می‌شود.

اگه چند صفحه باشند که همه‌شون کمترین تعداد دسترسی رو داشته باشند (یعنی مساوی باشند)، معمولاً قدیمی‌ترین صفحه بین اون‌ها جایگزین می‌شود. 

پیاده‌سازی الگوریتم \lr{LFU} می‌تواند نسبت به سایر الگوریتم‌ها پیچیده‌تر باشد، چون نیاز داره شمارش دقیقی از تعداد دفعات دسترسی به صفحه‌ها نگه داشته بشه و ممکنه نیاز به مرتب‌سازی یا دسترسی سریع به صفحه‌ای که کمترین استفاده رو داشته باشد، پیش بیاد. 

این الگوریتم فرض می‌کنه که در مواقعی که تعداد دفعات دسترسی برابر باشد، اصل \lr{FIFO} برای تعیین اولویت به کار می‌رود، یعنی قدیمی‌ترین صفحه بین اون‌ها که تعداد دفعات دسترسی‌شون یکسانه، جایگزین می‌شود.

به این ترتیب برای خروجی این روش خواهیم داشت:
\begin{align*}
1.\,\,  &Start: [] \\
2.\,\,  &Request\, 1: [1] \\
3.\,\,  &Request\, 3: [1, 3] \\
4.\,\,  &Request\, 5: [1, 3, 5] \\
5.\,\,  &Request\, 7: [1, 3, 5, 7] \\
6.\,\,  &Request\, 8: [3, 5, 7, 8] \\
7.\,\,  &Request\, 1: [5, 7, 8, 1] \\
8.\,\,  &Request\, 4: [7, 8, 1, 4] \\
9.\,\,  &Request\, 4: [7, 8, 1, 4] \,\, No Page Fault \\
10.\,\, &Request\, 3: [8, 1, 4, 3] \\
11.\,\, &Request\, 2: [1, 4, 3, 2] \\
12.\,\, &Request\, 4: [1, 4, 3, 2] \,\, No Page Fault \\
13.\,\, &Request\, 5: [4, 3, 2, 5] \\
14.\,\, &Request\, 1: [4, 3, 5, 1] \\
15.\,\, &Request\, 7: [4, 5, 1, 7] \\
16.\,\, &Request\, 1: [4, 5, 1, 7] \,\, No Page Fault
\end{align*}

\subsection*{د}
الگوریتم جایگزینی صفحه بهینه یک رویکرد نظریه‌ایه که بیشتر برای مقایسه و ارزیابی سایر الگوریتم‌های جایگزینی صفحه استفاده می‌شود. این الگوریتم نیاز به دانستن ترتیب درخواست‌های صفحه در آینده دارد.

الگوریتم صفحه‌ای رو جایگزین می‌کنه که در آینده برای مدت طولانی‌تری استفاده نخواهد شد. به عبارت دیگه، از بین صفحات فعلی در حافظه، صفحه‌ای رو برای جایگزینی انتخاب می‌کنه که دسترسی بهش دورتر در آینده انجام خواهد شد.

یادداشت:
الگوریتم بهینه در سیستم‌های واقعی قابل پیاده‌سازی نیست چون نیاز به دانستن درخواست‌های آینده دارد. با این حال، به عنوان یک معیار مفید برای مقایسه اثربخشی الگوریتم‌های جایگزینی صفحه عملی به کار می‌رود.

برای خروجی این روش نیز خواهیم داشت:

\begin{align*}
1.\,\, &Start: [] \\
2.\,\, &Request\, 1: [1] \\
3.\,\, &Request\, 3: [1, 3] \\
4.\,\, &Request\, 5: [1, 3, 5] \\
5.\,\, &Request\, 7: [1, 3, 5, 7] \\
6.\,\, &Request\, 8: [3, 5, 7, 8] \\
7.\,\, &Request\, 1: [5, 7, 8, 1] \\
8.\,\, &Request\, 4: [5, 8, 1, 4] \\
9.\,\, &Request\, 4: [5, 8, 1, 4] \,\, No Page Fault \\
10.\,\, &Request\, 3: [5, 1, 4, 3] \\
11.\,\, &Request\, 2: [1, 4, 3, 2] \\
12.\,\, &Request\, 4: [1, 4, 3, 2] \,\, No Page Fault \\
13.\,\, &Request\, 5: [1, 4, 2, 5] \\
14.\,\, &Request\, 1: [4, 2, 5, 1] \,\, No Page Fault \\
15.\,\, &Request\, 7: [4, 2, 1, 7] \\
16.\,\, &Request\, 1: [4, 2, 1, 7] \,\, No Page Fault
\end{align*}