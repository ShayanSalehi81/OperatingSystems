\subsection*{الف}
از آنجایی که در هر بلاک ۳۲ بایت داریم که فضای اشغالی هر پوینتر ۴ بایت است، می‌توانیم در هر بلاک
$32/4 = 8$
پوینتر داشته باشیم. حال با توجه به پوینترهای غیرمستقیم یک‌مرحله‌ای و دو‌مرحله‌ای داریم:
\[
    \implies \overbrace{2 \times 8 \times 32}^{\text{\lr{indirect index}}} + \overbrace{1 \times 8 \times 8 \times 32}^{\text{\lr{2-level indirect index}}} = 2560
\]
پس برای آدرس‌دهی فضای ۳۲۰۰ بایتی به
$3200 - 2560 = 640$
بایت دیگر نیاز داریم که از آنجایی که هر پوینتر مستقیم ۸ بایت را فضای دهی می‌کند می‌بایست ۸۰ پوینتر مستقیم به سیستم اضافه کنیم.

\subsection*{ب}
می‌دانیم که در
\lr{SSD}
به خاطر محدودیت حجم نوشتن داده‌ها بر روی خانه‌های حافظه تمایل داریم که تمام خانه‌ها به صورت یکنواخت از طرف سیستم استفاده شود. به این منظور نیاز است که فایل حال موقع استفاده و بازنویسی مجدد در قسمت جدید و کمتر استفاده شده حافظه نوشته شوند و به صورت بلاک‌های بزرگ نیز عمل پاک کردن انجام شود. با توجه به این توضیحات فایل سیستم
\lr{log-structured}
می‌تواند با بازنویسی جدید فایل‌های در قسمت‌های کمتر استفاده شده این قابلیت را به ما دهد. در صورتی که در فایل سیستم
\lr{inode based}
این کار بسیار سخت‌تر انجام شده و فایل‌های پرتغییر روی بخش خاصی از حافظه اجرا می‌شود و استفاده از حافظه را غیریکنواخت کرده که این مطلوب نیست.

\subsection*{ج}
آز آنجایی که در اینجا پنج درایو اصلی و پنج درایو بکاپ از آنها داریم، دو درایو خراب شده می‌تواند دو حالت داشته باشند:
\begin{itemize}
    \item
    اگر هر دو از حافظه‌های اصلی باشند، با کپی کردن مقادیر آنها از حافظه بکاپ می‌توانیم به راحتی مشکل را بازیابی کنیم.
    \item
    اگر یکی از قسمت اصلی و دیگری از بکاپ باشد و هردو نیز مربوط به یک درایو باشد. (اگر مربوط نباشند که همانند قسمت قبل می‌شود.)
    در این صورت به خاطر وجود مکانیزم
    \lr{RAID 5}
    می‌توانیم با 
    \lr{XOR}
    های تمام ۴ درایو دیگر اطلاعات این درایو را بازیابی کنیم.
\end{itemize}
پس در هر صورت امکان ریکاوری کردن فراهم است.