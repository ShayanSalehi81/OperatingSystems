\subsection*{آ}
نادرست،
\lr{Context switch} ممکن است به دلایل مختلفی از جمله تغییر در اولویت‌های برنامه‌ریزی وقتی که یک پردازه (process) در انتظار منابع است، یا برنامه‌ریزی زمانی برای اطمینان از توزیع منصفانه زمان پردازنده بین پردازه‌ها، رخ دهد. این فرآیند همیشه به صورت ناخواسته و در زمان‌های نامشخص رخ نمی‌دهد.

\subsection*{ب}
نادرست، در حالت عمومی، هر ریسه (thread) دارای استک (stack) اختصاصی خود است و به طور مستقیم نمی‌تواند به استک سایر ریسه‌ها دسترسی داشته باشد. دسترسی به داده‌های استک یک ریسه توسط ریسه‌ای دیگر نیازمند مکانیزم‌های خاصی مانند اشتراک‌گذاری حافظه است.

\subsection*{ج}
نادرست، تابع execv در لینوکس برای جایگزینی فعلی پردازه با یک پردازه جدید استفاده می‌شود، نه ایجاد یک پردازه جدید. این تابع، کد موجود در یک پردازه را با یک برنامه جدید جایگزین می‌کند. برای ایجاد یک پردازه جدید، معمولاً از تابع fork استفاده می‌شود، که یک کپی از پردازه فعلی را ایجاد می‌کند.

\subsection*{د}
درست، در سیستم‌های عاملی مانند UNIX و لینوکس، یک پردازه می‌تواند چندین \lr{file descriptor} داشته باشد که به یک \lr{file description} واحد اشاره می‌کنند. این امر به ویژه در مواردی مانند استفاده از توابعی چون fork یا دوباره باز کردن یک فایل مشاهده می‌شود.

\subsection*{ه}
نادرست، اگر تردها فقط برای خواندن داده‌ها از آرایه استفاده کنند. در مواردی که چندین ریسه (thread) فقط برای خواندن داده‌ها از یک منبع مشترک استفاده می‌کنند و هیچ نوشتنی در آن صورت نمی‌گیرد، \lr{race condition} به وجود نمی‌آید و نیازی به استفاده از مکانیزم‌های سینکرونایزیشن نیست. \lr{Race condition} زمانی رخ می‌دهد که چندین ریسه به طور همزمان داده‌ها را می‌خوانند و می‌نویسند.

\subsection*{و}
درست، در سیستم‌های عامل مدرن، فضای آدرس هر پردازه از دیگر پردازه‌ها مجزا و محافظت شده است. یک پردازه نمی‌تواند مستقیماً فضای حافظه یا آدرس‌دهی یک پردازه دیگر را تغییر دهد یا به آن دسترسی پیدا کند.

\subsection*{ز}
نادرست، زمان انتظار در الگوریتم \lr{Round Robin} نسبت به FCFS بستگی به عوامل متعددی دارد، از جمله طول دوره زمانی \lr{(time slice)} و خصوصیات ویژه بار کاری. در برخی موارد، زمان انتظار در \lr{Round Robin} می‌تواند کمتر از FCFS باشد، به خصوص اگر دوره زمانی به خوبی انتخاب شود و کارها زمان پردازش کوتاهی داشته باشند. اما در سایر موارد، ممکن است زمان انتظار در \lr{Round Robin} بیشتر از FCFS باشد.

\subsection*{ح}
نادرست، \lr{FCFS} \lr{(First-Come, First-Served)} یک الگوریتم غیر \lr{preemptive} است، یعنی وقتی یک پردازه شروع به اجرا می‌کند، تا پایان اجرای آن ادامه می‌یابد و نیازی به \lr{preemption} ندارد. اما \lr{Round Robin} یک الگوریتم \lr{preemptive} است. در \lr{Round Robin}، هر پردازه برای مدت زمان مشخصی \lr{(time slice)} اجرا می‌شود و پس از آن، اگر همچنان کاری برای انجام دادن داشته باشد، به انتهای صف انتظار منتقل می‌شود و پردازه بعدی شروع به اجرا می‌کند. این فرآیند نیازمند \lr{preemption} است.

\subsection*{ط}
نادرست، تأثیر الگوریتم‌های برنامه‌ریزی بر کارایی حافظه نهان به شدت به نوع برنامه‌ها و مدل دسترسی‌های حافظه آن‌ها بستگی دارد. در مواردی که برنامه‌ها به طور متناوب و با فاصله زمانی کوتاه اجرا شوند، ممکن است \lr{Round Robin} باعث بهبود دسترسی به داده‌های حافظه نهان شود، زیرا این الگوریتم از ایجاد وقفه‌های طولانی در اجرای هر پردازه جلوگیری می‌کند. اما در سایر موارد، به خصوص زمانی که پردازه‌ها دارای دسترسی‌های حافظه متمرکز و طولانی هستند، \lr{FCFS} ممکن است باعث کارایی بیشتر حافظه نهان شود.

\subsection*{ی}
نادرست، وقتی یک ریسه درون یک پردازه \lr{file descriptor} را می‌بندد، تنها برای آن پردازه بسته می‌شود، نه برای کل سیستم یا سایر پردازه‌ها. \lr{File descriptor} ها در سطح پردازه مدیریت می‌شوند، نه در سطح سیستم. بنابراین، بسته شدن یک \lr{file descriptor} توسط یک ریسه تنها برای همان پردازه‌ای که ریسه به آن تعلق دارد، تأثیر دارد.

\subsection*{ک}
درست، در پردازه‌های چند ریسه‌ای، هر ریسه دارای پشته \lr{(stack)} مخصوص به خود است. متغیرهایی که در پشته یک ریسه ذخیره می‌شوند، تنها توسط همان ریسه قابل دسترسی هستند و از دیگر ریسه‌ها مجزا هستند. بنابراین، دسترسی به این متغیرها \lr{thread-safe} است، زیرا هیچ تداخلی بین ریسه‌ها در دسترسی به این متغیرها وجود ندارد.

\subsection*{ل}
نادرست، اگرچه این الگوریتم می‌تواند به لحاظ نظری کارایی بالایی در کاهش زمان انتظار داشته باشد، اما بهینه‌ترین الگوریتم برای همه سناریوها و محیط‌های سیستم عامل نیست. عملکرد و کارایی یک الگوریتم زمان‌بندی به شدت به ماهیت بار کاری و خصوصیات سیستم وابسته است. همچنین، \lr{SRTF} می‌تواند منجر به مشکلاتی مانند
\lr{starvation}
برای پردازه‌های با زمان پردازش بلند شود.