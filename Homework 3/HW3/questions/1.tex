\subsection*{الف}
در اینجا می‌دانیم که برنامه
a
می‌تواند
y
و
z
را لاک کند همچنین برنامه
b
توانایی لاک کردن
x
و
z
و در نهایت برنامه
c
توانایی لاک‌ کردن
x
و
y
را دارد.

برای آنکه بتوانیم حالتی را معرفی کنیم که تردها دچار
\lr{Deadlock}
شوند. می‌توانیم ترتیبی به این صورت داشته باشیم:
\[
    a \to lock(y), \quad b \to lock(z), \quad c \to lock(x)
\]
به این ترتیب تمامی قسمت‌ها لاک شده و برنامه توانایی پیش‌روی را نخواهد داشت.

\subsection*{ب}
با تغییر ترتیب
\lr{mutex-unlock}
ها در اینجا نمی‌توان جلوی رخ دادن
\lr{Deadlock}
را گرفت زیرا که در قسمت الف، برنامه در خط اول لاک می‌شود و ترتیب اجرای دستورات
\lr{mutex-unlock}
اهمیتی نخواهند داشت و برنامه هیچ‌گاه به آنلاک نمی‌رسد.

\subsection*{ج}
از آنجایی که در زمان‌بندی
\lr{first come first served}
یک پردازه تا آخر انجام می‌شود و سپس به پردازه بعدی می‌رویم. هر پردازه در زمان اجرای خود دو واحد مموری را لاک کرده و سپس آنلاک می‌کند که به این ترتیب هیچ‌گاه به مشکل
\lr{Deadlock}
نخواهیم خورد.

\subsection*{د}
برای آنکه بتوانیم توالی ارائه دهیم که بتوان این مشکل را برطرف کرد می‌توان برنامه را از حالتی که هرکدام یک واحد جداگانه را لاک کند دربیارویم.

برای اینکار کافیست در پردازه
a
ترتیب لاک کردن
y
و
z 
را عوض کنیم. به این ترتیب هر دو پردازه
a
و
b
در ابتدا تلاش می‌کند که
z
را لاک کنند و یکی موفق می‌شوند. حال دو حالت داریم:
\begin{itemize}
    \item
    اگر پردازه
    c
    هر دو
    x
    و
    y
    را لاک کرده باشد. آنگاه پس از اجرای آن هر دو آنلاک شده و پردازه
    c
    کار خود را انجام داده و دو پردازه دیگر نیز می‌توانند بدون مشکل کار خود را به اتمام برسانند.
    
    \item
    x
    و
    y
    لاک نشده باشند. به این ترتیب پردازه
    a
    کار خود را اتمام کرده و 
    y
    و
    z
    را آزاد می‌کنند. سپس
    b
    می‌تواند به انتهای خود برسد و درنهایت پس از اتمام کار این دو پردازه
    c
    بدون هیچ اشکالی می‌تواند ران شود.
\end{itemize}
به این ترتیب
\lr{Deadlock}
در این حالت برطرف شده است.
